<!DOCTYPE html>
<html>
<head>
    <title>SignalR WebRTC Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.0/signalr.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        h1 {
            color: #333;
        }
        .container {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            width: 300px;
            text-align: center;
            box-sizing: border-box;
        }
        button, select, input[type="text"], input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        li {
            background: #e9e9e9;
            margin: 5px 0;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>SignalR WebRTC Demo</h1>
    <select id="clientSelect"></select>
    <input id="fileInput" type="file">
    <button onclick="startConnection()">Send File</button>
    <ul id="messagesList"></ul>
</div>

<script>
    const clientSelect = document.getElementById("clientSelect");
    const fileInput = document.getElementById("fileInput");
    const connection = new signalR.HubConnectionBuilder().withUrl("/signalling").build();
    const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    let peerConnection;
    let clientId;
    const ids = new Set();
    let metaDataChannel;
    let fileTransferDataChannel;
    let receiveBuffer = [];
    let receivedSize = 0;
    let fileTransferMetadata = {};

    connection.on("AddConnectedClient", addConnectedClient);
    connection.on("RemoveDisconnectedClient", removeDisconnectedClient);
    connection.on("ReceiveOffer", receiveOffer);
    connection.on("ReceiveAnswer", receiveAnswer);
    connection.on("ReceiveIceCandidate", receiveIceCandidate);
    connection.on("UpdateSelf", updateSelf);

    connection.start().catch(err => console.error(err.toString()));

    async function startConnection() {
        peerConnection = new RTCPeerConnection(configuration);
        const targetConnectionId = clientSelect.value;
        createPeerConnection(targetConnectionId);
        const offer = await createPeerOffer(peerConnection);
        connection.invoke("SendOffer", targetConnectionId, offer);
    }

    function createPeerConnection(clientId) {
        peerConnection.addEventListener('icecandidate', event => {
            if (event.candidate) {
                connection.invoke("SendIceCandidate", clientId, event.candidate);
            }
        });
        return peerConnection;
    }

    async function createPeerOffer(connection) {
        metaDataChannel = peerConnection.createDataChannel("file-metadata-channel");
        metaDataChannel.onopen = handleMetaDataChannelOpen;
        fileTransferDataChannel = peerConnection.createDataChannel("file-transfer");
        fileTransferDataChannel.binaryType = "arraybuffer";
        fileTransferDataChannel.addEventListener('open', onChannelStateChange);
        fileTransferDataChannel.addEventListener('close', onChannelStateChange);
        fileTransferDataChannel.addEventListener('error', onFileTransferChannelError);

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        return offer;
    }

    async function createPeerAnswer(peerConnection) {
        peerConnection.ondatachannel = handleDataChannel;
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        return answer;
    }

    function prepareFileTransfer() {
        const file = fileInput.files[0];
        if (file.size === 0) {
            console.error('File is empty, please select a non-empty file');
            return;
        }
        metaDataChannel.send(JSON.stringify({
            name: file.name,
            size: file.size,
            type: file.type,
            lastModified: file.lastModified
        }));
    }

    function sendFile() {
        const file = fileInput.files[0];
        const chunkSize = 16384;
        const fileReader = new FileReader();
        let offset = 0;

        fileReader.addEventListener('error', error => console.error('Error reading file:', error));
        fileReader.addEventListener('abort', event => console.log('File reading aborted:', event));
        fileReader.addEventListener('load', e => {
            fileTransferDataChannel.send(e.target.result);
            offset += e.target.result.byteLength;
            if (offset < file.size) {
                readSlice(offset);
            }
        });

        const readSlice = o => {
            const slice = file.slice(offset, o + chunkSize);
            fileReader.readAsArrayBuffer(slice);
        };
        readSlice(0);
    }

    function onChannelStateChange() {
        if (fileTransferDataChannel?.readyState === 'open' && metaDataChannel.readyState === 'open') {
            console.log(`File transfer channel state is: ${fileTransferDataChannel.readyState}`);
            console.log(`Meta data channel state is: ${metaDataChannel.readyState}`);
            prepareFileTransfer();
        }
    }

    function onFileTransferChannelError(error) {
        console.error('Error in sendChannel:', error);
    }

    function onReceiveMessageCallback(event) {
        receiveBuffer.push(event.data);
        receivedSize += event.data.byteLength;

        if (receivedSize === fileTransferMetadata.size) {
            const received = new Blob(receiveBuffer);
            receiveBuffer = [];
            const downloadAnchor = document.createElement('a');
            downloadAnchor.href = URL.createObjectURL(received);
            downloadAnchor.download = fileTransferMetadata.name;
            downloadAnchor.click();
            metaDataChannel.send(JSON.stringify({ isTransferComplete: true }));
            closeDataChannels();
        }
    }

    function closeDataChannels() {
        console.log('Closing data channels');
        fileTransferDataChannel.close();
        metaDataChannel.close();
        peerConnection.close();
        fileTransferDataChannel = null;
        metaDataChannel = null;
        peerConnection = null;
        fileTransferMetadata = {};
        receiveBuffer = [];
        receivedSize = 0;
    }

    function addConnectedClient(senderConnectionId) {
        ids.add(senderConnectionId);
        const clientOption = document.createElement("option");
        clientOption.value = senderConnectionId;
        clientOption.text = senderConnectionId;
        clientSelect.appendChild(clientOption);
    }

    function removeDisconnectedClient(senderConnectionId) {
        ids.delete(senderConnectionId);
        clientSelect.querySelector(`option[value="${senderConnectionId}"]`).remove();
    }

    async function receiveOffer(senderConnectionId, offer) {
        peerConnection = new RTCPeerConnection(configuration);
        createPeerConnection(senderConnectionId);
        await peerConnection.setRemoteDescription(offer);
        const answer = await createPeerAnswer(peerConnection);
        connection.invoke("SendAnswer", senderConnectionId, answer);
    }

    async function receiveAnswer(senderConnectionId, answer) {
        await peerConnection.setRemoteDescription(answer);
    }

    async function receiveIceCandidate(senderConnectionId, candidate) {
        await peerConnection.addIceCandidate(candidate);
    }

    function updateSelf(clientInfo) {
        clientId = clientInfo.selfId;
        clientInfo.otherClients.forEach(id => {
            ids.add(id);
            const clientOption = document.createElement("option");
            clientOption.value = id;
            clientOption.text = id;
            clientSelect.appendChild(clientOption);
        });
    }

    function handleMetaDataChannelOpen() {
        metaDataChannel.onmessage = event => {
            const data = JSON.parse(event.data);
            if (data.isTransferReady) {
                fileTransferMetadata = event.data;
                sendFile();
            } else if (data.isTransferComplete) {
                closeDataChannels();
            }
        };
    }

    function handleDataChannel(event) {
        receivedSize = 0;
        receiveBuffer = [];
        const { channel } = event;
        if (channel.label === "file-metadata-channel") {
            metaDataChannel = channel;
            metaDataChannel.onmessage = event => {
                const data = JSON.parse(event.data);
                data.isTransferReady = true;
                fileTransferMetadata = data;
                metaDataChannel.send(JSON.stringify(data));
            };
        } else if (channel.label === "file-transfer") {
            fileTransferDataChannel = channel;
            fileTransferDataChannel.binaryType = "arraybuffer";
            fileTransferDataChannel.onmessage = onReceiveMessageCallback;
            // fileTransferDataChannel.addEventListener('open', onChannelStateChange);
            // fileTransferDataChannel.addEventListener('close', onChannelStateChange);
            fileTransferDataChannel.addEventListener('error', onFileTransferChannelError);
        }
    }
</script>
</body>
</html>