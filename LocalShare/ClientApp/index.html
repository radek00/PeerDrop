<!DOCTYPE html>
<html>
<head>
    <title>SignalR WebRTC Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.0/signalr.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        h1 {
            color: #333;
        }
        .container {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            width: 300px;
            text-align: center;
            box-sizing: border-box;
        }
        button, select, input[type="text"], input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        li {
            background: #e9e9e9;
            margin: 5px 0;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SignalR WebRTC Demo</h1>
        <button onclick="startConnection()">Start Connection</button>
        <select id="clientSelect"></select>
        <input type="text" id="messageInput" placeholder="Enter a message" />
        <button onclick="sendMessage()">Send Message</button>
        <input id="fileInput" type="file">
        <button onclick="sendFile()">Send File</button>
        <button onclick="closeDataChannels()">Close Connection</button>
        <ul id="messagesList"></ul>
    </div>

    <script>
        //to do
        //1. Get all clients on connection to fill the select
        //2. Handle disconnecting\
        //3. Refactor the hub. A lot of stuff is redundant
        //4. Figure out how to send files
        //5. Close channels after file transfer
        //6. Send file metadata over one of the channels
        //7. Add progress bar for file transfer
        const clientSelect = document.getElementById("clientSelect");
        const fileInput = document.getElementById("fileInput");
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("/signalling")
            .build();

        const configuration = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };
        let peerConnection = new RTCPeerConnection(configuration);
        let clientId;
        const ids = new Set();
        let chatDataChannel;
        let fileTransferDataChannel;
        let receiveBuffer = [];
        let receivedSize = 0;


        connection.on("AddConnectedClient", async (senderConnectionId) => {
            ids.add(senderConnectionId);
            const clientOption = document.createElement("option");
            clientOption.value = senderConnectionId;
            clientOption.text = senderConnectionId;
            clientSelect.appendChild(clientOption);
            console.log("AddConnectedClient", senderConnectionId);
        });
        
        connection.on("RemoveDisconnectedClient", async (senderConnectionId) => {
            ids.delete(senderConnectionId);
            clientSelect.querySelector(`option[value="${senderConnectionId}"]`).remove();
            console.log("RemoveDisconnectedClient", senderConnectionId);
        });

        connection.on("ReceiveOffer", async (senderConnectionId, offer) => {
            createPeerConnection(senderConnectionId);
            await peerConnection.setRemoteDescription(offer);
            const answer = await createPeerAnswer(peerConnection);
            connection.invoke("SendAnswer", senderConnectionId, answer);
        });

        connection.on("ReceiveAnswer", async (senderConnectionId, answer) => {
            await peerConnection.setRemoteDescription(answer);
        });

        connection.on("ReceiveIceCandidate", async (senderConnectionId, candidate) => {
            await peerConnection.addIceCandidate(candidate);
        });

        connection.on("UpdateSelf", (clientInfo) => {
            clientId = clientInfo.selfId;
            for (const id of clientInfo.otherClients) {
                ids.add(id);
                const clientOption = document.createElement("option");
                clientOption.value = id;
                clientOption.text = id;
                clientSelect.appendChild(clientOption);
            }
            console.log("UpdateSelf", selfId);
        })

        connection.start().then(() => {
        }).catch(err => console.error(err.toString()));

        async function startConnection() {
            const targetConnectionId = clientSelect.value;
            createPeerConnection(targetConnectionId);
            const offer = await createPeerOffer(peerConnection);
            connection.invoke("SendOffer", targetConnectionId, offer);
        }

        function createPeerConnection(clientId) {
            peerConnection.addEventListener('icecandidate', event => {
                if (event.candidate) {
                    connection.invoke("SendIceCandidate", clientId, event.candidate);
                }
            });
            return peerConnection;
        }

        async function createPeerOffer(connection) {
            chatDataChannel = peerConnection.createDataChannel("my-rtc-chat");

            chatDataChannel.onopen = (_event) => {
                chatDataChannel.send(
                    "Hi! You have established peer-to-peer connection with me! Other users will also send you this message once they have their own connection!",
                );

                chatDataChannel.onmessage = (event) => {
                appendMessage(event.data);
            }
            
            };
            fileTransferDataChannel = peerConnection.createDataChannel("file-transfer");
            fileTransferDataChannel.binaryType = "arraybuffer";
            fileTransferDataChannel.addEventListener('open', onFileTransferChannelStateChange);
            fileTransferDataChannel.addEventListener('close', onFileTransferChannelStateChange);
            fileTransferDataChannel.addEventListener('error', onFileTransferChannelError);

            // create offer
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            return offer;
        }

        async function createPeerAnswer(peerConnection) {
            peerConnection.ondatachannel = (event) => {
                receivedSize = 0;
                receiveBuffer = [];
                console.log('event', event);
                const { channel } = event;
                if (channel.label === "my-rtc-chat") {
                    chatDataChannel = channel;
                    chatDataChannel.onopen = (_event) => {
                        chatDataChannel.send("Hi, I am new to this chat room!");
                    };
                    chatDataChannel.onmessage = (event) => {
                        appendMessage(event.data);
                    };
                } else if (channel.label === "file-transfer") {
                    fileTransferDataChannel = channel;
                    fileTransferDataChannel.binaryType = "arraybuffer";
                    fileTransferDataChannel.onmessage = onReceiveMessageCallback;
                    fileTransferDataChannel.onopen = onFileTransferChannelStateChange;
                    fileTransferDataChannel.addEventListener('open', onFileTransferChannelStateChange);
                    fileTransferDataChannel.addEventListener('close', onFileTransferChannelStateChange);
                    fileTransferDataChannel.addEventListener('error', onFileTransferChannelError);
                }
            };

            // create answer
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            return answer;
            
        }

        function sendMessage() {
            const message = document.getElementById("messageInput").value;
            const li = document.createElement("li");
            li.textContent = `You: ${message}`;
            document.getElementById("messagesList").appendChild(li);
            chatDataChannel.send(message);
        }

        function appendMessage(message) {
            const li = document.createElement("li");
            li.textContent = message;
            document.getElementById("messagesList").appendChild(li);
        }

        function sendFile() {
            const file = fileInput.files[0];
            console.log(`File is ${[file.name, file.size, file.type, file.lastModified].join(' ')}`);

            // Handle 0 size files.
            if (file.size === 0) {
                console.error('File is empty, please select a non-empty file');
                return;
            }
            const chunkSize = 16384;
            const fileReader = new FileReader();
            let offset = 0;
            fileReader.addEventListener('error', error => console.error('Error reading file:', error));
            fileReader.addEventListener('abort', event => console.log('File reading aborted:', event));
            fileReader.addEventListener('load', e => {
                console.log('FileRead.onload ', e);
                fileTransferDataChannel.send(e.target.result);
                offset += e.target.result.byteLength;
                console.log('offset', offset);
                if (offset < file.size) {
                    readSlice(offset);
                }
            });
            const readSlice = o => {
                console.log('readSlice ', o);
                const slice = file.slice(offset, o + chunkSize);
                fileReader.readAsArrayBuffer(slice);
            };
            readSlice(0);
        }

        function onFileTransferChannelStateChange() {
            if (fileTransferDataChannel) {
                const {readyState} = fileTransferDataChannel;
                console.log(`Send channel state is: ${readyState}`);
                if (readyState === 'open') {
                    //sendFile();
                }
            }
        }

        function onFileTransferChannelError(error) {
            if (fileTransferDataChannel) {
                console.error('Error in sendChannel:', error);
                return;
            }
            console.log('Error in sendChannel which is already closed:', error);
        }

        function onReceiveMessageCallback(event) {
            console.log(`Received Message ${event.data.byteLength}`);
            receiveBuffer.push(event.data);
            receivedSize += event.data.byteLength;
            
            console.log('progress', receivedSize);

            // we are assuming that our signaling protocol told
            // about the expected file size (and name, hash, etc).
            const file = fileInput.files[0];
            if (receivedSize === file.size) {
                const downloadAnchor = document.createElement('a');
                const received = new Blob(receiveBuffer);
                receiveBuffer = [];

                downloadAnchor.href = URL.createObjectURL(received);
                downloadAnchor.download = file.name;
                downloadAnchor.click();

                // const bitrate = Math.round(receivedSize * 8 /
                //     ((new Date()).getTime() - timestampStart));
                // bitrateDiv.innerHTML =
                //     `<strong>Average Bitrate:</strong> ${bitrate} kbits/sec (max: ${bitrateMax} kbits/sec)`;

                // if (statsInterval) {
                //     clearInterval(statsInterval);
                //     statsInterval = null;
                // }

                //closeDataChannels();
            }
        }

        function closeDataChannels() {
            console.log('Closing data channels');
            fileTransferDataChannel.close();
            chatDataChannel.close();
            fileTransferDataChannel = null;
            chatDataChannel = null;
            peerConnection.close();
            peerConnection = null;
            console.log('Closed peer connections');
        }
        
    </script>
</body>
</html>